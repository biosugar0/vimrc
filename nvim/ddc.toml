[[plugins]]
repo = 'Shougo/ddc.vim'
depends = ['context_filetype.vim', 'denops.vim', 'pum.vim','vim-vsnip','vim-vsnip-integ','skkeleton']
on_event = ['InsertEnter']
hook_post_source = '''
  set completeopt=menuone,preview
  call ddc#custom#patch_global('sources', ['around', 'file', 'rg', 'dictionary'] )
  call ddc#custom#patch_global('cmdlineSources', ['cmdline-history', 'input', 'file', 'around'] )

  call ddc#custom#patch_global('sourceOptions', {
        \ '_': {
        \   'ignoreCase': v:true,
        \   'matchers': ['matcher_fuzzy'],
        \   'sorters': ['sorter_fuzzy'],
        \   'converters': [
        \     'converter_remove_overlap', 'converter_truncate_abbr'
        \   ],
        \ },
        \ 'around': {
        \   'mark': 'A',
        \   'matchers': ['matcher_head', 'matcher_length'],
        \ },
        \ 'cmdline': {
        \   'mark': 'cmdline',
        \   'forceCompletionPattern': '\S/\S*',
        \   'dup': v:true,
        \ },
        \ 'input': {
        \   'mark': 'input',
        \   'forceCompletionPattern': '\S/\S*',
        \   'isVolatile': v:true,
        \   'dup': v:true,
        \ },
        \ 'nvim-lsp': {
        \   'mark': 'lsp',
        \   'forceCompletionPattern': '\.|:|->|"\w+/*',
        \   'ignoreCase': v:true,
        \   'isVolatile': v:true
        \ },
        \ 'dictionary': {
        \   'matchers': ['matcher_fuzzy'],
        \   'sorters': ['sorter_fuzzy'],
        \   'converters': ['converter_fuzzy'],
        \   'maxItems': 15,
        \   'mark': 'D',
        \   'minAutoCompleteLength': 3,
        \ },
        \ 'cmdline-history': {
        \   'mark': 'history',
        \   'sorters': [],
        \ },
        \ 'shell-history': {'mark': 'shell'},
        \ 'zsh': {
        \   'mark': 'zsh',
        \   'isVolatile': v:true,
        \   'forceCompletionPattern': '\S/\S*'
        \ },
        \ 'rg': {
        \   'mark': 'rg',
        \   'matchers': ['matcher_head', 'matcher_length'],
        \   'minAutoCompleteLength': 5,
        \   'enabledIf': "finddir('.git', ';') != ''",
        \ },
        \ 'file': {
        \   'mark': 'file',
        \   'isVolatile': v:true,
        \   'minAutoCompleteLength': 1000,
        \   'forceCompletionPattern': '\S/\S*',
        \ },
        \ 'vsnip': {
        \ 'dup': v:true,
        \ 'mark': 'snip',
        \ },
        \ 'skkeleton' : {
        \   'mark': 'skk',
        \   'converters': [],
        \   'matchers': ['skkeleton'],
        \   'sorters': [],
        \   'minAutoCompleteLength': 2,
        \   'maxCandidates': 50,
        \ },
        \ })
  call ddc#custom#patch_filetype(
      \ ['help', 'markdown', 'gitcommit'], 'sources',
      \ ['input', 'around', 'rg']
      \ )
  call ddc#custom#patch_filetype(
            \ ['typescript', 'go', 'python','hcl','toml'], 'sources',
            \ ['input', 'nvim-lsp', 'around','vsnip','dictionary']
            \ )
  call ddc#custom#patch_filetype(['FineCmdlinePrompt'], {
      \ 'keywordPattern': '[0-9a-zA-Z_:#]*',
      \ 'sources': ['cmdline-history', 'cmdline', 'around'],
      \ 'specialBufferCompletion': v:true,
      \ })
  " Use pum.vim
  call ddc#custom#patch_global('autoCompleteEvents', [
      \ 'InsertEnter', 'TextChangedI', 'TextChangedP',
      \ 'CmdlineEnter', 'CmdlineChanged',
      \ ])
  call ddc#custom#patch_global('completionMenu', 'pum.vim')
  call ddc#custom#set_context('go', { ->
      \ ddc#syntax#in('TSComment') ? {
      \   'sources': ['around'],
      \ } : {} })
  call ddc#custom#patch_global('sourceParams', {
    \ 'dictionary': {
    \   'dictPaths': ['/usr/share/dict/words'],
    \   'smartCase': v:true,
    \   'showMenu': v:false
    \ },
    \ })

  call ddc#enable()

  imap <silent><expr> <Tab> vsnip#available(1) ? '<Plug>(vsnip-expand-or-jump)' : ddc#map#pum_visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' : ddc#can_complete() ? ddc#manual_complete() : '<Tab>'
  smap <silent><expr> <TAB> vsnip#available(1) ? '<Plug>(vsnip-expand-or-jump)' : ddc#map#pum_visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' : ddc#can_complete() ? ddc#manual_complete() : '<TAB>'
  imap <silent><expr> <C-n> pum#visible() ? '<Cmd>call pum#map#select_relative(+1)<CR>' : '<Cmd>call ddc#map#manual_complete()<CR><Cmd>call pum#map#select_relative(+1)<CR>'
  imap <silent><expr> <S-TAB> vsnip#jumpable(-1) ? '<Plug>(vsnip-jump-prev)' : pum#visible() ? '<Cmd>call pum#map#insert_relative(-1)<CR>' : '<S-TAB>'
  smap <silent><expr> <S-TAB> vsnip#jumpable(-1) ? '<Plug>(vsnip-jump-prev)' : pum#visible() ? '<Cmd>call pum#map#insert_relative(-1)<CR>' : '<S-TAB>'
  imap <silent><expr> <C-p> pum#visible() ? '<Cmd>call pum#map#select_relative(-1)<CR>' : '<Cmd>call ddc#map#manual_complete()<CR><Cmd>call pum#map#select_relative(-1)<CR>'
  inoremap <silent><expr> <CR> pum#visible() ? '<Cmd>call pum#map#confirm()<CR>' : ddc#map#pum_visible() ? '<Cmd>call pum#map#confirm()<CR>' : '<CR>'
  imap <silent><expr> <Esc> pum#visible() ? '<Cmd>call pum#map#cancel()<CR>' : '<Esc>'
  smap <silent><expr> <C-n>  vsnip#jumpable(1)  ? '<Plug>(vsnip-jump-next)' :  '<C-n>'
  imap <silent><expr> <C-n>  ddc#map#pum_visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :  '<Cmd>normal! gj<CR>'

  " For command line mode completion
  cnoremap <expr> <Tab> pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' : exists('b:ddc_cmdline_completion') ? ddc#manual_complete() : nr2char(&wildcharm)
  cnoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
  cnoremap <C-c>   <Cmd>call pum#map#cancel()<CR>
  cnoremap <C-o>   <Cmd>call pum#map#confirm()<CR>

  imap <expr> <C-k> vsnip#expandable() ? '<Plug>(vsnip-expand)' : '<C-k>'
  smap <expr> <C-k> vsnip#expandable() ? '<Plug>(vsnip-expand)' : '<C-k>'

  autocmd User PumCompleteDone call vsnip_integ#on_complete_done(g:pum#completed_item)

  " For skkeleton
  function! s:skkeleton_init() abort
    call skkeleton#config({
    \   'eggLikeNewline': v:true,
    \   'registerConvertResult': v:true,
    \   'showCandidatesCount': 1,
    \   'globalJisyo': g:globalJisyo,
    \   'userJisyo': g:skk_dir .. '/SKK-JISYO.user',
    \ })
    " from shougo-s-github
    call skkeleton#register_kanatable('rom', {
      \ 'jj': 'escape',
      \ '~':         ['〜',     ''],
      \ '...':       ['…',     ''],
      \ ",\<Space>": ['、',     ''],
      \ "z\<Space>": ["\u3000", ''],
      \ ".\<Space>": ['。',     ''],
      \ "(\<Space>": ['（',     ''],
      \ ")\<Space>": ['）',     ''],
      \ "/\<Space>": ['・',     ''],
    \ })
  endfunction
  function! s:skkeleton_pre() abort
    " Save current sources
    let b:skkeleton_ddc_sources_backup = get(ddc#custom#get_current(), 'sources', [])
    let sources = get(b:, 'skkeleton_ddc_sources', ['skkeleton'])
    call ddc#custom#patch_buffer('sources', sources)
    " call pum#set_option('setline_insert', v:true)
  endfunction
  autocmd User skkeleton-disable-pre call s:skkeleton_post()
  function! s:skkeleton_post() abort
    " Restore current sources
    call ddc#custom#patch_buffer('sources', b:skkeleton_ddc_sources_backup)
    call pum#set_option('setline_insert', v:false)
  endfunction
  autocmd User skkeleton-initialize-pre call s:skkeleton_init()
  autocmd User skkeleton-enable-pre call s:skkeleton_pre()
'''
hook_add = '''
  nnoremap :       <Cmd>call CommandlinePre(':')<CR>:
  nnoremap ?       <Cmd>call CommandlinePre('/')<CR>?
  function! CommandlinePre(mode) abort
    " Note: It disables default command line completion!
    set wildchar=<C-t>
    set wildcharm=<C-t>
    cnoremap <expr><buffer> <Tab>
    \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
    \ exists('b:ddc_cmdline_completion') ? ddc#manual_complete() : "\<C-t>"
    " Overwrite sources
    if !exists('b:prev_buffer_config')
      let b:prev_buffer_config = ddc#custom#get_buffer()
    endif
    if a:mode ==# ':'
      call ddc#custom#patch_buffer('cmdlineSources',
              \ ['cmdline-history', 'cmdline', 'around'])
      call ddc#custom#patch_buffer('keywordPattern', '[0-9a-zA-Z_:#]*')
    else
      call ddc#custom#patch_buffer('cmdlineSources',
              \ ['around', 'line'])
    endif
    autocmd MyAutoCmd User DDCCmdlineLeave ++once call CommandlinePost()
    autocmd MyAutoCmd InsertEnter <buffer> ++once call CommandlinePost()
    call ddc#enable_cmdline_completion()
  endfunction
  function! CommandlinePost() abort
    silent! cunmap <buffer> <Tab>
    " Restore sources
    if exists('b:prev_buffer_config')
      call ddc#custom#set_buffer(b:prev_buffer_config)
      unlet b:prev_buffer_config
    else
      call ddc#custom#set_buffer({})
    endif
    set wildcharm=<Tab>
  endfunction
'''

[[plugins]]
repo = 'Shougo/context_filetype.vim'
on_source = 'ddc.vim'
hook_source = '''
let g:context_filetype#ignore_patterns = {
    \ 'toml': ['^\s*#\s*'],
    \ }
'''

[[plugins]]
repo = 'Shougo/pum.vim'
on_source = 'ddc.vim'
hook_post_source = '''
  hi NoneBg guibg=#000000
  call pum#set_option('max_width', 80)
  call pum#set_option('border', '')
  call pum#set_option('padding', v:true)
'''

[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-zsh'
on_source = 'ddc.vim'
depends = 'ddc.vim'

[[plugins]]
repo = 'tani/ddc-fuzzy'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-cmdline'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-input'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-rg'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-line'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-nvim-lsp'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-matcher_head'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-matcher_length'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-cmdline-history'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-converter_remove_overlap'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-converter_truncate_abbr'
on_source = 'ddc.vim'

[[plugins]]
repo = 'LumaKernel/ddc-file'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-omni'
on_source = 'ddc.vim'

[[plugins]]
repo = 'matsui54/ddc-dictionary'
on_source = 'ddc.vim'

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
on_source = 'vim-vsnip-integ'

[[plugins]]
repo = 'hrsh7th/vim-vsnip-integ'
on_source = 'ddc.vim'
depends = ['vim-vsnip']

[[plugins]]
repo = 'vim-skk/skkeleton'
on_cmd= '<Plug>(skkeleton-'
hook_add = '''
imap <C-j> <Plug>(skkeleton-toggle)
cmap <C-j> <Plug>(skkeleton-toggle)
'''
hook_source = '''
let g:skk_dir = expand('~/.local/share/skk')
let g:globalJisyo = g:skk_dir .. '/SKK-JISYO.L'
if !filereadable(g:globalJisyo)
  echomsg 'Installing skk global jisyo ...'
  let s:gzipfile = g:globalJisyo .. '.gz'
  call system('curl -fLo ' .. s:gzipfile .. ' --create-dirs '
        \ .. 'https://skk-dev.github.io/dict/SKK-JISYO.L.gz')
  call system('gzip -d ' .. s:gzipfile)
endif
'''
